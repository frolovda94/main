<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <script src="jquery-2.1.1.min.js"></script>
    <script src="d3.min.js"></script>
    <title>Frolov Dmitry</title>
    <style>
        .node circle {
            fill: #fff;
            stroke: steelblue;
            stroke-width: 2px;
        }
        .node text {
            font: 20px sans-serif;
        }
        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 2px;
        }
    </style>
</head>

<body>

    <p style="color: steelblue; font-family:comic sans ms">Welcome! Enter a regular expression. Allowed input: 0-9, ., +, -, *, /, ^, (, ).
		<span style="padding-right:50px;float:right; color:red">by Frolov Dmitry<br>Last update: 16.09.2014</span>
        <br>
        <span class="expanded" style="color: red"> <br>(1.7+.1)*2<br>(1+7)*(24/7+3)<br>72+37*(25^2-1)<br>-5+11-(-(-(-3)))<br>(-(-4+2))^2<br></span>
        <span class="collapsed"></span>
        <a href="javascript:void(0)" class="collapsed">Examples</a>
        <a href="javascript:void(0)" class="expanded">Collapse</a>
        <br>
		<br>
        <input type="text" id="input" class="custom" size="80" autofocus>
        <br>
        <input type="button" id="parse" onclick="Parse()" value="Parse">
        <input type="button" id="reset" onclick="Clear()" value="Clear">
        <span id="output_exp"></span>
		<span style="color:red" id="output_err"></span>
		<span id="output_postfix"></span>
		<span id="output_count"></span>
    </p>

    <script>
        $(document).ready(function() {
            $(".expanded").hide();

            $(".expanded, .collapsed").click(function() {
                $(this).parent().children(".expanded, .collapsed").toggle();
            });
        });
    </script>

    <script>
	
        treeData = [];
		
		function is_operator(c){
			if(c=='+'||c=='-'||c=='*'||c=='/'||c=='^') return true;
			else return false;
		}
		
		function operators_cmp(a, b){
			var a_prior, b_prior;
			if(a=='+'||a=='-') a_prior = 1;
			else if(a=='*'||a=='/') a_prior = 2;
			else if(a=='^') a_prior = 3;
			if(b=='+'||b=='-') b_prior = 1;
			else if(b=='*'||b=='/') b_prior = 2;
			else if(b=='^') b_prior = 3;
			else if(b=='(') b_prior = 0;
			if(b_prior>=a_prior) return true;
			else return false;
		}
		
		function raise_err(txt){
			var res = {"code":0, "text":txt};
			return res;
		}
		
		function string_correction(in_text) {
			var res = "";
			var i,k,brackets = 0,doubles=0, dots = 0,flag=0;
			// (brackets/doubles/dots) - для подсчета числа (скобок/идущих подряд чисел/точек в одном числе). 
			
			for(i=0;i<in_text.length;i++) {
				k = res.length-1; //индекс последнего элемента итоговой строки
				if(k==-1&&in_text[i]=='+') continue; //Случай, когда строка начинается с плюса, игнорируем плюс
				if(k==-1&&in_text[i]!='-'&&is_operator(in_text[i])) return raise_err("Error! Input string shouldn't start with an operator");
				if(k==-1&&in_text[i]=='-'){ //Проверяем случай -(...)
					var m=i+1;
					while(in_text[m]==' '&&m<in_text.length()-1) m++; //смотрим ближайший символ справа, кроме пробелов
					if(in_text[m]=='('){
						res+="0-";
						continue; 
					}
				}
				if(k>=0&&is_operator(in_text[i])&&is_operator(res[k])) return raise_err("Error! Two operators one by one");
				if(in_text[i]>='0'&&in_text[i]<='9'&&flag==0) {doubles++; flag=1;}
				if(doubles==2) return raise_err("Error! Two numbers one by one without an operator");
				if(in_text[i]=='.') dots++; //при помощи dots вычисляем ошибочные числа типа 12.13.3
				if(!(in_text[i]<='9'&&in_text[i]>='0')&&in_text[i]!='.') dots = 0;
				if(dots==2) return raise_err("Error! Two dots at one number");
				if(is_operator(in_text[i])) {
					doubles=0; flag=0; var j=0;
					if(k>=0&&in_text[i]=='+'&&res[k]=='(') continue; //Случай, когда плюс идет сразу после открытой скобки, игнорируем его
					while(k>=0&&(res[k]=='('||res[k]==')')) {k--;j++;} //Пишем в k индекс последнего элемента res, кроме скобок 
					if(k==-1||(k>=0&&is_operator(res[k]))){
						if(k>=0 && in_text[i]!='-') return raise_err("Error! Two operators one by one");
						else { 
							var m = i+1; //индекс след. символа, не равного пробелу.
							while(m<in_text.length && in_text[m]==' ') m++; 
							if(m<in_text.length&&res[k+j]=='('&&in_text[m]=='(') res+='0'; //Например, 4-(-(3*7)) = 4-(0-(3*7))
							else if(m<in_text.length && !((in_text[m]>='0'&&in_text[m]<='9')||in_text[m]=='.')) return raise_err("Error! Incorrect symbol '" + in_text[m] + "' afrer '-'");
						}
					}
					k+=j;//возвращаем k прежнее значение
				}
				else if(in_text[i]=='('){
					brackets++;
					if(k>=0&&!is_operator(res[k])&&res[k]!='(') return raise_err("Error! An operator expected before '('");
				}
				else if(in_text[i]==')'){
					brackets--;
					if(brackets<0) break;
					if(k>=0&&is_operator(res[k])) return raise_err("Error! Incorrect symbol '" + res[k] + "' before ')'");
				}
				else if(!is_operator(in_text[i])&&in_text[i]!=' '&&in_text[i]!='('&&in_text[i]!=')'&&in_text[i]!='.'&&!(in_text[i]>='0'&&in_text[i]<='9'))
					return raise_err("Error! Incorrect symbol '" + in_text[i] + "'");
				if(in_text[i]=='.'&&(!(k>=0&&res[k]>='0'&&res[k]<='9')||k==-1)){
					res+="0.";
					continue;
				}
					//return raise_err("Error! Incorrect symbol '.'");
				if(in_text[i]!=' ') res += in_text[i];
				else flag = 0;
			}
			if(brackets!=0) return raise_err("Error! Mismatched brackets");
			if(res.length>0){
				var j=0;
				k = res.length-1;
				while ((k-j)>=0 && (res[k-j]=='('||res[k-j]==')'||res[k-j]==' ')) j++;
				if((k-j)==-1) return raise_err("Error! Expression can't contain only brackets");
				else if(is_operator(res[k-j])) return raise_err("Error! Expression can't finish with an operator");
			}
			else return raise_err("Error! The input is empty");
			var result = {"code":1, "text":res};
			return result;

		}
		
		function postfix_form(formula){
			var result = "";
			var operators = []; //стек с операторами, для реализации алгоритма
			var i=0;
			while(i<formula.length){
				if(formula[i]>='0'&&formula[i]<='9') { //читаем число
					while(i<formula.length &&((formula[i]>='0'&&formula[i]<='9')||formula[i]=='.')){
						result+=formula[i++];
					}
					result+=" ";
				}
				else if(formula[i]=='(') {operators.push(formula[i]); i++;}
				else if(formula[i]==')'){
					var t = " ";
					while(t[0]!='('){
						t = operators.pop();
						if(t[0]!='(') {
							result+=t;
							result+=" ";
						}
					}
					i++;
				}
				else if(i==0||(formula[i]=='-'&&(/*is_operator(formula[i-1])||*/formula[i-1]=='('))){
					i++; result+="-";
					while(i<formula.length &&((formula[i]>='0'&&formula[i]<='9')||formula[i]=='.')){
						result+=formula[i++];
					}
					result+=" ";					//этот else if отвечает за считывание отрицательных чисел
				}
				else if(is_operator(formula[i])){
					if(operators.length==0||formula[i]=='^') {operators.push(formula[i]); i++;}
					else{
						var t = operators.pop();
						var flag = true; //флаг нужен, чтобы не потерять последний вытолкнутый t, если мы не дошли до конца стека
						while(operators_cmp(formula[i],t[0]))	{
							result+=t; result+=" ";
							if(!(operators.length==0)) t = operators.pop();
							else { flag = false; break;}
						}
						if(flag) operators.push(t[0]);
						operators.push(formula[i]);
						i++;
					}
				}
				else {result = "Unexpected error"; operators.length=0; break;}
				// В этот else мы никогда не должны попасть, но, во избежание зацикливания, если я вдруг что-то не учел, введу его.
			}
			while(!(operators.length==0)) {result+=operators.pop(); result+=" ";}
			return result;
		}
		
		function generate_tree_data(postfix_exp) {
			var postfix_arr = [];
			var stack = []; //стек узлов дерева, в итоге в нем останется 1 элемент - корень
			postfix_arr = postfix_exp.split(' '); // разбили выражение на массив элементов
			for(var i = 0; i<postfix_arr.length; i++){
				var el = postfix_arr[i]; //Элемент выражения (число, либо оператор)
				if(!is_operator(el)){ //если это число
					var node = {"name": parseFloat(el), "children": [], "value": parseFloat(el)};
					stack.push(node);
				}
				else {
					var second = stack.pop();
					var first = stack.pop();
					var node = {"name": el, "children": [first, second], "value": Math.floor(use_operator(first.value, second.value, el)*1000)/1000};
					stack.push(node);
				}
			}
			treeData[0]=stack[0];
		}
		
		function use_operator(a,b,op){
			if(op=='+') return a+b;
			if(op=='-') return a-b;
			if(op=='*') return a*b;
			if(op=='/') return a/b;
			if(op=='^') return Math.pow(a,b);
		}

		function Parse() {
			Clear();
			$(".expanded").hide();
			$(".collapsed").show();
			var result = string_correction(document.getElementById("input").value);
			if(result.code == 0) document.getElementById("output_err").innerHTML = "<br>"+result.text;
			else{
				document.getElementById("output_exp").innerHTML = "<br>Equal expression:\t" + result.text;	
				document.getElementById("output_postfix").innerHTML = "<br>Postfix notation:\t" + postfix_form(result.text);
				generate_tree_data(postfix_form(result.text));
				document.getElementById("output_count").innerHTML = "<br>Result:\t" + treeData[0].value; //Округляем до 3х знаков
				Draw();
			}
		}

        function Draw() {
            // ************** Generate the tree diagram	 *****************
            var margin = {
                    top: 40,
                    right: 60,
                    bottom: 20,
                    left: 60
                },
                width = $(window).width()*3/4 - margin.right - margin.left,
                height = $(window).height() - margin.top - margin.bottom;

            var i = 0;

            var tree = d3.layout.tree()
                .size([height, width]);

            var diagonal = d3.svg.diagonal()
                .projection(function(d) {
                    return [d.x, d.y];
                });

            var svg = d3.select("body").append("svg")
                .attr("width", width + margin.right + margin.left)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            root = treeData[0];

            update(root);

            function update(source) {

                // Compute the new tree layout.
                var nodes = tree.nodes(root).reverse(),
                    links = tree.links(nodes);

                // Normalize for fixed-depth.
                nodes.forEach(function(d) {
                    d.y = d.depth * 100;
                });

                // Declare the nodes…
                var node = svg.selectAll("g.node")
                    .data(nodes, function(d) {
                        return d.id || (d.id = ++i);
                    });

                // Enter the nodes.
                var nodeEnter = node.enter().append("g")
                    .attr("class", "node")
                    .attr("transform", function(d) {
                        return "translate(" + d.x + "," + d.y + ")";
                    });

                nodeEnter.append("circle")
                    .attr("r", 22)
                    .style("fill", "#fff");

                nodeEnter.append("text")
                    //	  .attr("y", function(d) { 
                    //		  return d.children || d._children ? -18 : 18; })
                    .attr("dy", ".35em")
                    .attr("text-anchor", "middle")
                    .text(function(d) {
                        return d.name;
                    })
                    .style("fill-opacity", 1);
					
				nodeEnter.append("text")
					.attr("y", function(d) { 
						return d.children || d._children ? -30 : 0; })
					.attr("x", function(d) { 
                    	return d.children || d._children ? 30 : 0; })
                    .attr("dy", ".35em")
                    .attr("text-anchor", "middle")
                    .text(function(d) {
						return d.children || d._children ? d.value : "";
                    })
					.style("font-size", "16px")
					.style("fill", "#777");

                // Declare the links…
                var link = svg.selectAll("path.link")
                    .data(links, function(d) {
                        return d.target.id;
                    });

                // Enter the links.
                link.enter().insert("path", "g")
                    .attr("class", "link")
                    .attr("d", diagonal);

            }
        }

        function Clear() {
            d3.select("svg")
                .remove();
			document.getElementById("output_exp").innerHTML = "";
			document.getElementById("output_err").innerHTML = "";
			document.getElementById("output_postfix").innerHTML = "";
			document.getElementById("output_count").innerHTML = "";
        }
    </script>

</body>

</html>